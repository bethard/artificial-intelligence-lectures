% !TEX TS-program = pdflatexmk

\documentclass[14pt]{beamer}
\input{../slides-preamble}
\usepackage{hhline}
\lstset{emph={[2]__init__,__str__}}

\usepackage{synttree}
\newcommand{\node}[1]{{\parbox{1.25in}{\centering #1}}}

\title{First-Order Logic}
\date{18 Feb 2014}

\begin{document}

\begin{frame}
	\titlepage
\end{frame}
\begin{frame}{Outline}
	\tableofcontents
\end{frame}

\section{First Order Logic}
\begin{frame}{What's Wrong with Propositional Logic?}
	Translate: \\
	\tab\emph{All squares adjacent to pits are breezy}
	\pause
	\begin{block}{Problem: Propositional Logic}
		$
		\begin{array}{l}
		B_{1,1} \liff (P_{1,2} \lor P_{2,1}) \\
		B_{1,2} \liff (P_{1,1} \lor P_{2,2} \lor P_{1,3}) \\
		B_{2,1} \liff (P_{1,1} \lor P_{2,2} \lor P_{2,1}) \\
		\ldots
		\end{array}
		$
	\end{block}
	\pause
	\begin{block}{Solution: First Order Logic (Preview)}
		$\forall s\ \textit{Breezy}(s) \liff \exists r\ \textit{Adjacent}(r, s) \land \textit{Pit}(r)$
	\end{block}
\end{frame}
\begin{frame}{Core Ideas of First Order Logic}
	\begin{block}{Propositional Logic}
		\begin{itemize}
			\item World consists of \emph{facts}
			\item All facts are either true or false
		\end{itemize}
	\end{block}
	\pause
	\begin{block}{First Order Logic}
		\begin{itemize}
			\item World consists of \emph{objects} and \emph{relations}
			\item Statements that a relation $R$ holds between objects $X_1$, \ldots, $X_n$ are either true or false
		\end{itemize}
		\pause
		\begin{description}
			\item[Objects] people, numbers, houses, colors, years\ldots
			\item[Relations]
				blonde, round, prime, multi-storied\ldots \\
			  brother-of, comes-between, has-color, after\ldots
		\end{description}
	\end{block}
\end{frame}

\subsection{Core Components}
%\begin{frame}{Components of First Order Logic}
%	\extrarowheight=.5em 
%	\begin{tabular}{ll}
%		\keyword{Constants}   & $KingJohn,\ 2,\ UCB,\ \ldots$ \\
%		\keyword{Predicates}  & $Brother,\ >,\ \ldots$ \\
%		\keyword{Functions}   & $Sqrt,\ LeftLegOf,\ \ldots$ \\
%		\keyword{Variables}   & $x,\ y,\ a,\ b,\ \ldots$ \\
%		\keyword{Connectives} & $\land\ \lor\ \lnot\ \limpl\ \liff$ \\
%		\keyword{Equality}    & $=$ \\
%		\keyword{Quantifiers} & $\forall\ \exists$ \\
%	\end{tabular}
%\end{frame}
\begin{frame}{Constants}
	\begin{block}{Key Idea}
		\alert{Constants} represent named objects in the world
	\end{block}
	\begin{block}{Examples}
		\em
		\begin{tabular}{l}
			RichardTheLionheart \\
			RonaldMcDonald \\
			Blue \\
			42 \\
			12pm \\
		\end{tabular}
	\end{block}
\end{frame}
\begin{frame}{Functions}
	\begin{block}{Key Idea}
		\alert{Functions} relate object(s) to \emph{exactly one} other object
	\end{block}
	\begin{block}{Examples}
		\begin{tabular}{ll}
			$\textit{LeftLegOf}(x)$ \\
			$\textit{LengthOf}(x)$ \\
			$\textit{SquareRoot}(x)$,      & i.e. $\sqrt{x}$ \\
			$\textit{Sum}(x, y)$,          & i.e. $x + y$ \\
			$\textit{Intersection}(x, y)$, & i.e. $x \cap y$ \\
		\end{tabular}
	\end{block}
\end{frame}
\begin{frame}{Predicates}
	\begin{block}{Key Idea}
		\alert{Predicates} describe relations between objects \\
		\tab(or a property of a single object)
	\end{block}
	\begin{block}{Examples}
		\begin{tabular}{ll}
			$\textit{Person}(x)$ \\
			$\textit{Female}(x)$ \\
			$\textit{BrotherOf}(x, y)$ \\
			$\textit{Positive}(x)$,     & i.e. $x > 0$ \\
			$\textit{MemberOf}(x, y)$,  & i.e. $x \in y$ \\
			$\textit{SubsetOf}(x, y)$,  & i.e. $x \subseteq y$ \\
		\end{tabular}
	\end{block}
\end{frame}
\begin{frame}{Connectives}
	\begin{block}{Connectives in First-Order Logic}
		\begin{itemize}
			\item Used to construct more complex sentences
			\item Semantics match those of Propositional Logic
		\end{itemize}
	\end{block}
	\begin{block}{Examples}
		\extrarowheight=.25em 
		$
		\begin{array}{ll}
			\lnot\textit{Brother}(\textit{LeftLeg}(\textit{Richard}), \textit{John}) \\
			\textit{Positive}(42) \land \textit{LessThan}(42, 100) \\
			\textit{Male}(\textit{Pat}) \lor \textit{Female}(Pat) \\
			\lnot\textit{LaysEggs}(\textit{Whale}) \limpl \lnot\textit{Bird}(\textit{Whale})
		\end{array}
		$
	\end{block}
\end{frame}

\begin{frame}{Truth in First Order Logic}
\begin{block}{Key Ideas}
\begin{itemize}
\item Relations are (possibly infinite) sets of tuples
\item $\textit{R}(\textit{Term}_1, \ldots, \textit{Term}_n)$ true iff $\langle\textit{Term}_1, \ldots, \textit{Term}_n\rangle \in \textit{R}$
\end{itemize}
\end{block}
\begin{block}{Example}
Given relation
$\textit{SquareRoot} = \{
\langle 1, 1 \rangle,
\langle 4, 2 \rangle,
\langle 9, 3 \rangle,
\ldots \}$
\begin{description}[$\textit{SquareRoot}(X, X)$]
\pause\item[$\textit{SquareRoot}(4, 2)$?] \pause true
\pause\item[$\textit{SquareRoot}(2, 2)$?] \pause false
\end{description}
\end{block}
\end{frame}

\subsection{Quantifiers}
\begin{frame}{Quantifiers}
	\begin{block}{Predicating over Constants}
		If I know: \\
		\tab$\lnot\textit{LaysEggs}(\textit{Whale}) \limpl \lnot\textit{Bird}(\textit{Whale})$ \\[.5em]
		What can I say here? \\
		\tab$\lnot\textit{LaysEggs}(\textit{Steve}) \limpl ?$ \\[.5em]
		\pause
		\alert{Nothing!}
	\end{block}
	\pause
	\begin{block}{Quantifiers and Variables}
		Quantifiers allow statements about classes of objects, e.g. \\
		\tab$\forall x\ \lnot\textit{LaysEggs}(x) \limpl \lnot\textit{Bird}(x)$
	\end{block}
\end{frame}
\begin{frame}{Universal Quantification ($\forall$)}
	\begin{block}{Definition}
		$\forall x\ P$ is true in model $m$ iff: \\
		\tab$P$ is true when we bind $x$ to \alert{each} of the objects in $m$
	\end{block}
	\pause
	\begin{block}{Example}
		So $\forall x\ \textit{Bird}(x) \limpl \textit{LaysEggs}(x)$ is true because: \\
		\tab$\textit{Bird}(\textit{Swallow}) \limpl \textit{LaysEggs}(\textit{Swallow})$ is true \\
		\tab$\textit{Bird}(\textit{Emu}) \limpl \textit{LaysEggs}(\textit{Emu})$ is true \\
		\tab$\textit{Bird}(\textit{Badger}) \limpl \textit{LaysEggs}(\textit{Badger})$ is true \\
		\tab\ldots \\[.5em]
		\pause
		But $\forall x\ \textit{LaysEggs}(x) \limpl \textit{Bird}(x)$ is false because: \\
		\pause
		\tab$\textit{LaysEggs}(\textit{Platypus}) \limpl \textit{Bird}(\textit{Platypus})$ is false
	\end{block}
\end{frame}
\begin{frame}{Universal Quantification in Translation}
	\begin{block}{Common Mistake}
		What does this mean? \\
		\tab$\forall x\ \textit{Bird}(x) \land \textit{LaysEggs}(x)$ \\
		\pause
		Answer: \\
		\tab\emph{Everything is a bird and everything lays eggs} \\
		Intended statement: \\
		\tab$\forall x\ \textit{Bird}(x) \limpl \textit{LaysEggs}(x)$ \\
	\end{block}
	\pause
	\begin{block}{Rule of Thumb}
		Use implication ($\limpl$) with universal quantification ($\forall$)
	\end{block}
\end{frame}
\begin{frame}{Existential Quantification}
	\begin{block}{Definition}
		$\exists x\ P$ is true in model $m$ iff: \\
		\tab$P$ is true when we bind $x$ to \alert{any} of the objects in $m$
	\end{block}
	\pause
	\begin{block}{Example}
		So $\exists x\ \textit{Mammal}(x) \land \textit{LaysEggs}(x)$ is true because: \\
		\pause
		\tab$\textit{Mammal}(\textit{Platypus}) \land \textit{LaysEggs}(\textit{Platypus})$ is true \\[.5em]
		\pause
		But $\exists x\ \textit{Mammal}(x) \land \lnot\textit{Animal}(x)$ is false because: \\
		\pause
		\tab$\textit{Mammal}(\textit{Person}) \land \lnot\textit{Animal}(\textit{Person})$ is false \\
		\tab$\textit{Mammal}(\textit{Platypus}) \land \lnot\textit{Animal}(\textit{Platypus})$ is false \\
		\tab$\textit{Mammal}(\textit{Spam}) \land \lnot\textit{Animal}(\textit{Spam})$ is false \\
		\tab\ldots \\
	\end{block}
\end{frame}
\begin{frame}{Existential Quantification in Translation}
	\begin{block}{Common Mistake}
		What does this mean? \\
		\tab$\exists x\ \textit{Mammal}(x) \limpl \textit{LaysEggs}(x)$ \\
		\pause
		Answer: \\
		\tab\emph{There is something that is not a mammal or lays eggs} \\
		Intended statement: \\
		\tab$\exists x\ \textit{Mammal}(x) \land \textit{LaysEggs}(x)$ \\
	\end{block}
	\pause
	\begin{block}{Rule of Thumb}
		Use conjunction ($\land$) with existential quantification ($\exists$)
	\end{block}
\end{frame}
\begin{frame}{Quantifier Properties}
	\begin{block}{Nesting Quantifiers}
		Mixed quantifiers cannot be exchanged:
		\begin{itemize}
			\item $\forall x\ \exists y\ \textit{Loves}(x, y)$ ``everyone loves someone''
			\item $\exists x\ \forall y\ \textit{Loves}(x, y)$ ``one person is loved by everyone''
		\end{itemize}
	\end{block}
	\pause
	\begin{block}{Relation between $\forall$ and $\exists$}
		Conversion is roughly like DeMorgan's:
		\begin{itemize}
			\item $\forall x\ \textit{Enjoys}(x, \textit{AI}) \equiv \lnot\exists x\ \lnot \textit{Enjoys}(x, \textit{AI})$
			\item $\exists x\ \textit{Enjoys}(x, \textit{DB}) \equiv \lnot\forall x\ \lnot \textit{Enjoys}(x, \textit{DB})$
		\end{itemize}
	\end{block}
\end{frame}
\begin{frame}{Equality Relations}
	\begin{block}{Problem}
		What's wrong with this definition? \\
		\tab$\forall x, y\ \textit{Sibling}(x, y) \liff \exists p\ \textit{Parent}(p, x) \land \textit{Parent}(p, y)$ \\[1em]
		\pause
		Both $x$ and $y$ can be the same thing! \\
		\tab$\textit{Sibling}(\textit{Steve}, \textit{Steve})$
	\end{block}
	\pause
	\begin{block}{Solution: Equality}
		Specify when two variables refer to the same objects: \\[.5em]
		$\forall x, y\ \textit{Sibling}(x, y) \! \liff \! x \! \neq \! y \! \land \! \exists p\ \textit{Parent}(p, x) \! \land \! \textit{Parent}(p, y)$
	\end{block}
\end{frame}

\subsection{Example Translations}

\begin{frame}{Animal Kingdom Translations}
\begin{itemize}
\item
All horses are mammals \\
\uncover<2->{$\forall x\ \textit{Horse}(x) \limpl \textit{Mammal}(x)$}
\item
All birds have wings \\
\uncover<3->{$\forall x\ \textit{Bird}(x) \limpl \textit{HasWings}(x)$}
\item
Some mammals lay eggs \\
\uncover<4->{$\exists x\ \textit{Mammal}(x) \land \textit{LaysEggs}(x)$}
\item
Some birds don't fly \\
\uncover<5->{$\exists x\ \textit{Bird}(x) \land \lnot\textit{Flies}(x)$}
\item
Animals that fly have wings \\
\uncover<6->{$\forall x\ \textit{Animal}(x) \land \textit{Flies}(x) \limpl \textit{HasWings}(x)$}
\item
Not all swimming animals have fins \\
\uncover<7->{$\lnot\forall x\ \textit{Animal}(x) \land \textit{Swim}(x) \limpl \textit{HasFins}(x)$ \\
$\exists x\ \textit{Animal}(x) \land \textit{Swim}(x) \land \lnot\textit{HasFins}(x)$}
\end{itemize}
\end{frame}

\begin{frame}{Animal Kingdom Translations}
\begin{itemize}
\item
An animal gives birth to animals of the same species \\
\uncover<2->{$
\begin{array}{ll}
\lefteqn{\forall x,y\ \textit{Animal}(x) \land \textit{GivesBirth}(x, y) \limpl \mbox{}} \\
& \textit{Animal}(y) \land \textit{Species}(x) = \textit{Species}(y) \land x \neq y 
\end{array}
$}
\bigskip
\item
Bats have exactly two wings \\
\uncover<3->{$
\begin{array}{lll}
\lefteqn{\forall x\ \textit{Bat}(x) \limpl \mbox{}} \\
& \lefteqn{\exists y,z\ \textit{HasWing}(x, y) \land \textit{HasWing}(x, z) \land y \neq z \land \mbox{}} \\
& & \forall w\ \textit{HasWing}(x, w) \limpl w = y \lor w = z
\end{array}
$}
\end{itemize}
\end{frame}

\begin{frame}{Wumpus World Translations}
\begin{itemize}
\item
There is a breeze in $[3, 1]$ \\
\uncover<2->{$\textit{Breezy}([3, 1])$}
\bigskip
\item
The Wumpus is lives in $[2, 2]$ \\
\uncover<3->{$\textit{Home}(\textit{Wumpus}) = [2, 2]$}
\bigskip
\item
If you are in the Wumpus's square, he eats you \\
\uncover<4->{$
\begin{array}{ll}
\lefteqn{\forall t\ \textit{Location}(\textit{Agent}, \textit{Home}(\textit{Wumpus}), t) \limpl \mbox{}} \\
& \textit{HasEaten}(\textit{Wumpus}, \textit{Agent}, t)
\end{array}
$}
\bigskip
\item
You should grab the gold when you are in its square \\
\uncover<5->{$
\begin{array}{ll}
\lefteqn{\forall s,t\ \textit{HasGold}(s) \land \textit{Location}(\textit{Agent}, s, t) \limpl \mbox{}} \\
& \textit{BestAction}(\textit{Grab}, \textit{Agent}, t)
\end{array}
$}
\end{itemize}
\end{frame}

\begin{frame}{Wumpus World Translations}
	\begin{block}{Diagnostic Rules}
		From effect, determine cause: \\
		\tab$\forall y\ \textit{Breezy}(y) \limpl (\exists x\ \textit{Pit}(x) \land \textit{Adjacent}(x, y))$
	\end{block}
	\pause
	\begin{block}{Causal Rules}
		From cause, determine effect: \\
		\tab$\forall x,y\ (\textit{Pit}(x) \land \textit{Adjacent}(x, y)) \limpl \textit{Breezy}(y)$
	\end{block}
	\pause
	\begin{block}{Definition Rules}
		Bidirectional: \\
		\tab$\forall y\ \textit{Breezy}(y) \liff (\exists x\ \textit{Pit}(x) \land \textit{Adjacent}(x, y))$
	\end{block}
\end{frame}

\begin{frame}{Harry Potter's 7 Potions Puzzle}
	\footnotesize
	\begin{tabular}{l}
		Danger lies before you, while safety lies behind, \\
		Two of us will help you, whichever you would find. \\
		One among us seven will let you move ahead, \\
		Another will transport the drinker back instead. \\
		Two among our number hold only nettle wine, \\
		Three of us are killers, waiting hidden in line. \\
		Choose, unless you wish to stay here forevermore, \\
		To help you in your choice, we give you these clues four: \\
		First, however slyly the poison tries to hide \\
		You will always find some on nettle wine's left side; \\
		Second, different are those who stand at either end, \\
		But if you would move forward, niether is your friend; \\
		Third, as you see clearly, all are different size, \\
		Neither dwarf nor giant holds death in their insides; \\
		Fourth, the second left and second on the right \\
		Are twins once you taste them, though different at first sight.	 \\
	\end{tabular}
\end{frame}
\begin{frame}{One Harry Potter's 7 Potions Solution}
	$
	\begin{array}{lll}
	\lefteqn{\forall p\ \textit{Potions}(p) \liff \mbox{}} \\
	& \textit{Permutation}(p, [\textit{Forward}, \textit{Backward}, \textit{Wine}, \textit{Wine}, \\
	& \hspace{7em}         \textit{Poison}, \textit{Poison}, \textit{Poison}]) \\
	& \textit{PoisonIsLeftOfWine}(p) \land \mbox{} \\
	& \textit{EndsAreDifferent}(p) \land \textit{EndsAreNotForward}(p) \land \mbox{} \\
	& \textit{SmallestIsNotPoison}(p) \land \textit{LargestIsNotPoison}(p) \\
	& \textit{SecondsAreTheSame}(p) \land \mbox{} \\
	\lefteqn{\ldots} \\
	\pause
	\lefteqn{\forall p\ \textit{EndsAreDifferent}(p) \liff \mbox{}} \\
	& \exists p_1, p_2, \ldots, p_7\ p = [p_1, p_2, p_3, p_4, p_5, p_6, p_7] \land p_1 \neq p_7 \\
	\lefteqn{\ldots} \\
	\pause
	\lefteqn{\forall p\ \textit{LargestIsNotPoison}(p) \liff \mbox{}} \\
	& \exists p_i\ \textit{Largest}(p, p_i) \land p_i \neq \textit{Poison}
	\end{array}
	$
\end{frame}
\begin{frame}
	\begin{center}
		\Huge Prolog Demo
	\end{center}
\end{frame}

\section{First-Order Logic Inference}

\subsection{Propositionalization}

\begin{frame}{Universal Instantiation}
	\begin{block}{Key Idea}
		If we know $\forall x\ P(x)$, then we can conclude: \\
		\begin{itemize}
			\item $P(\textit{Badger})$
			\item $P(\textit{Spam})$
			\item \ldots
		\end{itemize}
	\end{block}
	\pause
	\begin{block}{Formal Rule}
		Given a ground term $g$: \\[.5em]
		$
		\begin{array}{l}
		\forall v\ \alpha \\
		\hline
		\textsc{Subst}(\{v/g\}, \alpha)
		\end{array}
		$
	\end{block}
\end{frame}

\begin{frame}{Existential Instantiation}
	\begin{block}{Key Idea}
		If we know $\exists x\ P(x)$, then we can just give a name to $x$: \\
		\begin{itemize}
			\item $P(\textit{ThingThatPIsTrueFor})$
		\end{itemize}
		This works as long as the name isn't already in use
	\end{block}
	\pause
	\begin{block}{Formal Rule}
		Given a constant $k$ that is not in the knowledge base: \\[.5em]
		$
		\begin{array}{l}
		\exists v\ \alpha \\
		\hline
		\textsc{Subst}(\{v/k\}, \alpha)
		\end{array}
		$ \\[.5em]
		The constant $k$ is called a \alert{Skolem constant}
	\end{block}
\end{frame}

\begin{frame}{Reduction to Propositional Logic}
\begin{block}{First-Order Logic}
$
\begin{array}{l}
\exists x\ \textit{Mammal}(x) \land \textit{LaysEggs}(x) \\
\forall x\ \textit{Mammal}(x) \limpl \textit{WarmBlooded}(x) \\
\textit{Mammal}(\textit{Platypus}) \\
\lnot \textit{WarmBlooded}(\textit{Crocodile})
\end{array}
$
\end{block}
\pause
\begin{block}{Propositional Logic}
$
\begin{array}{l}
\textit{Mammal9X23B} \land \textit{LaysEggs9E23B} \\
\textit{MammalPlatypus} \limpl \textit{WarmBloodedPlatypus} \\
\textit{MammalCrocodile} \limpl \textit{WarmBloodedCrocodile} \\
\textit{MammalPlatypus} \\
\lnot \textit{WarmBloodedCrocodile}
\end{array}
$
\end{block}
\end{frame}

\begin{frame}{Simple First-Order Inference}
	\begin{block}{Simple Approach}
		\begin{itemize}
			\item Remove $\forall$ and $\exists$
			\item Treat all first-order terms as simple symbols
			\item Solve using resolution for propositional logic
		\end{itemize}
	\end{block}
	\pause
	\begin{block}{Example: $\textit{WarmBlooded}(\textit{Platypus})$?}
		$
		\begin{array}{l}
			\lnot\textit{WarmBlooded}(\textit{Platypus}) \\
			\lnot\textit{Mammal}(\textit{Platypus}) \lor \textit{WarmBlooded}(\textit{Platypus}) \\
			\hline
			\lnot\textit{Mammal}(\textit{Platypus}) \\
			\textit{Mammal}(\textit{Platypus}) \\
			\hline
			\textit{false}
		\end{array}
		$
	\end{block}
\end{frame}

\begin{frame}{Simple First-Order Inference}
	\begin{block}{Problem: Infinite Terms}
		\begin{itemize}
			\item $\textit{Mammal}(\textit{Steve})$
			\item $\textit{Mammal}(\textit{Mother}(\textit{Steve}))$
			\item $\textit{Mammal}(\textit{Mother}(\textit{Mother}(\textit{Steve})))$
			\item \ldots
		\end{itemize}
	\end{block}
	\pause
	\begin{block}{Solution: Iterative Deepening}
		\begin{itemize}
			\item Try proof with terms up to depth 1
			\item Try proof with terms up to depth 2
			\item \ldots
		\end{itemize}
		\pause
		Proof found if exists\pause, else infinite loop \pause (\alert{semidecidable})
	\end{block}
\end{frame}

\subsection{Generalized Modus Ponens}

\begin{frame}{Problems with Propositionalization}
	\begin{block}{Prove: $\textit{WarmBlooded}(\textit{Scooby})$}
		$
		\begin{array}{l}
			\textit{Dog}(\textit{Scooby}) \\
			\textit{Dog}(\textit{Scrappy}) \\
			\forall x\ \textit{Dog}(x) \limpl \textit{Mammal}(x) \\
			\forall y\ \textit{Mammal}(y) \limpl \textit{WarmBlooded}(y) \\
		\end{array}
		$
	\end{block}
	\begin{block}{Problem: Many Irrelevant Facts Produced}
		$
		\begin{array}{l}
			\textit{Dog}(\textit{Scrappy}) \\
			\textit{Dog}(\textit{Scrappy}) \limpl \textit{Mammal}(\textit{Scrappy}) \\
			\textit{Mammal}(\textit{Scrappy}) \limpl \textit{WarmBlooded}(\textit{Scrappy}) \\
		\end{array}
		$
	\end{block}
\end{frame}

\begin{frame}{Generalized Modus Ponens}
\small
\extrarowheight=.25em
\begin{columns}[T]
\begin{column}{0.5\textwidth}
\begin{block}{Definition}
$
\begin{array}{l}
p_1' \\
p_2' \\
\ldots \\
p_n' \\
p_1 \land p_2 \land \ldots \land p_n \limpl q \\
\theta : \forall i\ \textsc{Subst}(\theta, p_i') = \textsc{Subst}(\theta, p_i)\\
\hline
\textsc{Subst}(\theta, q)
\end{array}
$
\end{block}
\end{column}
\pause
\begin{column}{0.45\textwidth}
\begin{block}{Example}
$
\begin{array}{l}
\textit{Odd}(17) \\
\forall x\ \textit{Odd}(x) \limpl \textit{Mod}(x, 2, 1) \\
\theta = \{x = \textit{17}\} \\
\hline
\pause\textit{Mod}(17, 2, 1)
\end{array}
$
\end{block}
\end{column}
\end{columns}
\end{frame}

\begin{frame}{Unification}
\begin{block}{Formally}
$\textsc{Unify}(p, q) = \theta \mbox{ where } \textsc{Subst}(\theta, p) = \textsc{Subst}(\theta, q)$
\end{block}
\bigskip
\begin{block}{Example: $p=\textit{Eats}(\textit{Panda}, y)$}<2->
\thickmuskip=0mu
\medskip
$
\begin{array}{@{} l l @{}}
q & \textsc{Unify}(p, q) \\
\hline
\textit{Eats}(\textit{Panda}, \textit{Leaves})
& \uncover<3->{\{y=\textit{Leaves}\}}
\\
\textit{Eats}(x, \textit{Pizza})
& \uncover<4->{\{x=\textit{Panda}, y=\textit{Pizza}\}}
\\
\textit{Eats}(x, \textit{FavFood}(x))
& \uncover<5->{\{x=\textit{Panda}, y=\textit{FavFood}(\textit{Panda})\}}
\end{array}
$
\end{block}
\end{frame}

\subsection{Forward Chaining}

\begin{frame}{Forward Chaining}
	\begin{block}{Key Ideas}
		\begin{itemize}
			\item Repeatedly apply Generalized Modus Ponens
			\item Stop when nothing new can be inferred
		\end{itemize}
	\end{block}
	\pause
	\begin{block}{Details}
		KB must be only \alert{first-order definite clauses}, one of:
		\begin{itemize}
			\item Atomic clauses, e.g. $\textit{Mammal}(\textit{Platypus})$
			\item Implications like $p_1 \land p_2 \land \ldots \land p_n \limpl q$
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}{Forward Chaining Example}
	\begin{tabular}{p{0.97\textwidth}}
		If you're rich and someone sells something you want, you buy it \\
		\tab$\textit{Rich}(x) \land \textit{Wants}(x, y) \land \textit{Sells}(z, y) \limpl \textit{Buys}(x, y)$ \\
		If you're hot, you want ice cream \\
		\tab$\textit{Hot}(x) \land \textit{IceCream}(y) \limpl \textit{Wants}(x, y)$ \\
		HaagenDazs sells all kinds of ice cream \\
		\tab$\textit{IceCream}(y) \limpl \textit{Sells}(\textit{HaagenDazs}, y)$ \\
		One flavor of ice cream is mint \\
		\tab$\textit{IceCream}(\textit{Mint})$ \\
		Bill is rich \\
		\tab$\textit{Rich}(\textit{Bill})$ \\
		Bill is hot \\
		\tab$\textit{Hot}(\textit{Bill})$
	\end{tabular}
\end{frame}

\begin{frame}{Forward Chaining Example}
$
\begin{array}{l}
\textit{Hot}(\textit{Bill}) \\
\textit{IceCream}(\textit{Mint}) \\
\textit{Hot}(x) \land \textit{IceCream}(y) \limpl \textit{Wants}(x, y) \\
\hline
\visible<2->{
\textit{Wants}(\textit{Bill}, \textit{Mint}) \\[.8em]}
\visible<3->{
\textit{IceCream}(\textit{Mint}) \\
\textit{IceCream}(y) \limpl \textit{Sells}(\textit{HaagenDazs}, y) \\
\hline}
\visible<4->{
\textit{Sells}(\textit{HaagenDazs}, \textit{Mint}) \\[.8em]}
\visible<5->{
\textit{Rich}(\textit{Bill}) \\
\textit{Wants}(\textit{Bill}, \textit{Mint}) \\
\textit{Sells}(\textit{HaagenDazs}, \textit{Mint}) \\
\textit{Rich}(x) \land \textit{Wants}(x, y) \land \textit{Sells}(z, y) \limpl \textit{Buys}(x, y) \\
\hline}
\visible<6->{
\textit{Buys}(\textit{Bill}, \textit{Mint})}
\end{array}
$
\end{frame}

\begin{frame}{Forward Chaining Properties}
\begin{block}{Basic Properties}
\begin{itemize}
\item Sound - uses Generalized Modus Ponens
\item Complete - proof similar to propositional logic
\item Works only with definite clauses
\end{itemize}
\end{block}
\begin{block}{Termination}<2->
With no functions, $p$ predicates, $n$ constants, and at most $k$ arguments per predicate: \\[.5em]
\begin{description}[Maximum Iterations?]
\item[Maximum Facts?] \uncover<3->{$pn^k$}
\item[Maximum Iterations?] \uncover<4->{$pn^k$}
\item[With $f$ functions?] \uncover<5->{May never terminate}
\end{description}
\end{block}
\end{frame}

\begin{frame}{Optimizing Forward Chaining}
	\begin{block}{Indexing}
		\begin{itemize}
			\item Treat facts like database relations
			\item Index by predicate + arguments
			\item Can get $O(1)$ fact retrieval
			\item Standard time/space tradeoffs
		\end{itemize}
	\end{block}
	\begin{block}{Rule Checking}
		\begin{itemize}
			\item Don't check all rules on each iteration
			\item Check rules when new part of premise is satisfied
		\end{itemize}
	\end{block}
\end{frame}

\subsection{Backward Chaining}
\begin{frame}{Backward Chaining}
	\begin{block}{Key Ideas}
		\begin{itemize}
			\item Start with the terms in the query
			\item Look for sentences that can conclude those terms using Generalized Modus Ponens
			\item Recurse as necessary to find simple terms
		\end{itemize}
	\end{block}
	\begin{block}{Details}
		\begin{itemize}
			\item KB must be only first-order definite clauses
		\end{itemize}
	\end{block}
\end{frame}
\begin{frame}[fragile]{Backward Chaining Code}
	\begin{semiverbatim}\bfseries\scriptsize
		\keyword{def} \defn{backward_chaining}(knowledge_base, goals, assignment):
		    \pause\cmnt{# if all goals have been resolved, generate the assignment}
		    \keyword{if} \keyword{not} goals:
		        \keyword{yield} assignment
		    \pause\cmnt{# otherwise, check the first goal and then recurse}
		    \keyword{else}:
		        term = assignment.substitute(goals[0])
		        \keyword{for} sentence \keyword{in} knowledge_base:
		            \pause\cmnt{# try to unify the sentence with the first goal}
		            new_assignment = unify(sentence.head, term)
		            \keyword{if} new_assignment \keyword{is} \keyword{None}:
		                \keyword{continue}
		            \pause\cmnt{# add the sentence's premise to the remaining goals}
		            new_goals = list(sentence.body)
		            new_goals.extend(goals[1:])
		            new_assignment = new_assignment.compose(assignment)
		            \pause\cmnt{# recursively search for the remaining goals}
		            args = knowledge_base, new_goals, new_assignment
		            \keyword{for} result \keyword{in} backward_chaining(*args):
		                \keyword{yield} result
	\end{semiverbatim}
\end{frame}
\begin{frame}{Backward Chaining Example}
	Given:
	\\[.5em]
	$
	\begin{array}{l}
		\textit{Rich}(x) \land \textit{Wants}(x, y) \land \textit{Sells}(z, y) \limpl \textit{Buys}(x, y) \\
		\textit{Hot}(x) \land \textit{IceCream}(y) \limpl \textit{Wants}(x, y) \\
		\textit{IceCream}(y) \limpl \textit{Sells}(\textit{HaagenDazs}, y) \\
		\textit{IceCream}(\textit{Mint}) \\
		\textit{Rich}(\textit{Bill}) \\
		\textit{Hot}(\textit{Bill})
	\end{array}
	$
	\\[1em]
	Query:
	\\[.5em]
	$
	\begin{array}{l}
		\textit{Buys}(x, y)
	\end{array}
	$
\end{frame}
\begin{frame}{Backward Chaining Example}
	\small
	$
	\begin{array}{@{}ll@{}}
		\mbox{Goals}                                                        & \mbox{Assignment} \\
		\hline
		\pause\left[\textit{Buys}(x, y)\right]                                  & \{\} \\
		\pause\left[\textit{Rich}(x), \textit{Wants}(x, y), \textit{Sells}(z, y)\right] & \{\} \\
		\pause\left[\textit{Wants}(x, y), \textit{Sells}(z, y)\right]               & \{x\!\!=\!\!\textit{Bill}\} \\
		\pause\left[\textit{Hot}(x), \textit{IceCream}(y), \textit{Sells}(z, y)\right]  & \{x\!\!=\!\!\textit{Bill}\} \\
		\pause\left[\textit{IceCream}(y), \textit{Sells}(z, y)\right]               & \{x\!\!=\!\!\textit{Bill}\} \\
		\pause\left[\textit{Sells}(z, y)\right]                                 & \{x\!\!=\!\!\textit{Bill}, y\!\!=\!\!\textit{Mint}\} \\
		\pause\left[\textit{IceCream}(y)\right]                                 & \{x\!\!=\!\!\textit{Bill}, y\!\!=\!\!\textit{Mint}, z\!\!=\!\!\textit{HaagenDazs}\} \\
		\pause\left[\right]                                                 & \{x\!\!=\!\!\textit{Bill}, y\!\!=\!\!\textit{Mint}, z\!\!=\!\!\textit{HaagenDazs}\} \\
	\end{array}
	$
\end{frame}
\begin{frame}{Backward Chaining Properties}
	\begin{block}{Properties}
		\begin{tabular}{@{}ll@{}}
			\pause\keyword{Sound}       & \pause Yes, uses Generalized Modus Ponens \\[.5em]
			\pause\keyword{Complete}    & \pause No, could hit infinite loops \\
			                        & \pause $\Rightarrow$ fix by keeping track of goals already seen \\[.5em]
			\pause\keyword{Space}       & \pause Linear in size of proof (depth-first search) \\
		\end{tabular}
	\end{block}
\end{frame}

\subsection{Prolog}
\begin{frame}[fragile]{Prolog}
	\begin{block}{Prolog Overview}
		\begin{itemize}
			\item Backward chaining + many optimizations
			\item Millions of logical inferences per second
		\end{itemize}
	\end{block}
	\pause
	\begin{block}{Prolog Syntax}
		\begin{itemize}
			\item Head first, then body
			\item Predicates lowercase, variables uppercase
			\item Comma for $\land$, semicolon for $\lor$
		\end{itemize}
		\begin{semiverbatim}\bfseries\footnotesize
			\defn{factorial}(1, 1).
			\defn{factorial}(\str{N}, \str{_}) :- \str{N} =< 0, \keyword{fail}.
			\defn{factorial}(\str{N}, \str{F}) :- \str{N} > 1, \str{N1} \keyword{is} \str{N} - 1,
			                   factorial(\str{N1}, \str{F1}), \str{F} \keyword{is} \str{F1} * \str{N}.
		\end{semiverbatim}
	\end{block}
\end{frame}
\begin{frame}
	\begin{center}
		\Huge Prolog Examples
	\end{center}
\end{frame}
\begin{frame}{Backwards Chaining Backtracking}
	\small
	\extrarowheight=.25em
	$
	\begin{array}{@{}l@{\hspace{.3em}}l@{}}
	\mbox{Prove:}    & \textit{Connected}(A, F) \\
	\mbox{Given:}    & \forall x,z\ \textit{Edge}(x,z)\!\limpl\!\textit{Connected}(x,z) \\
	                 & \forall x,y,z\ \textit{Edge}(x,y)\!\land\!\textit{Connected}(y,z)\!\limpl\!\textit{Connected}(x, z) \\
	                 & \textit{Edge}(A, B) \land \textit{Edge}(B, C) \land \textit{Edge}(B, D) \land \textit{Edge}(D, F)\\
	\end{array}
	$ \\	
	\bigskip
	\pause
	\branchheight{2.5em}
	\synttree
	[\node{$\textit{Connected}(A, F)$}
		[\node{\only<-2>{\invisible{$\textit{Edge}(A, F)$}}
		       \only<3-4>{$\textit{Edge}(A, F)$}
		       \only<5>{\invisible{$\textit{Edge}(A, F)$}}
		       \only<6-7>{$\textit{Edge}(A, y)$}
		       \only<8->{$\textit{Edge}(A, B)$}}
			[\node{\only<-3>{\invisible{$\textit{Edge}(A, B)$}}
			       \only<4>{$\textit{fail}$}
			       \only<7->{$\textit{Edge}(A, B)$}}]]
		[\node{\only<-5>{\invisible{$\textit{Connected}(B, F)$}}
		       \only<6-7>{$\textit{Connected}(y, F)$}
		       \only<8->{$\textit{Connected}(B, F)$}}
			[\node{\only<-8>{\invisible{$\textit{Edge}(B, y)$}}
			       \only<9-10>{$\textit{Edge}(B, y)$}
			       \only<11-12>{$\textit{Edge}(B, C)$}
			       \only<13-14>{$\textit{Edge}(B, y)$}
			       \only<15->{$\textit{Edge}(B, D)$}}
				[\node{\only<-9>{\invisible{$\textit{Edge}(B, C)$}}
				       \only<10-12>{$\textit{Edge}(B, C)$}
				       \only<13>{\invisible{$\textit{Edge}(B, C)$}}
				       \only<14->{$\textit{Edge}(B, D)$}}]]
			[\node{%\only<-8>{\invisible{$\textit{Connected}(D, F)$}}
			       \only<9-10>{$\textit{Connected}(y, F)$}
			       \only<11-12>{$\textit{Connected}(C, F)$}
			       \only<13-14>{$\textit{Connected}(y, F)$}
			       \only<15->{$\textit{Connected}(D, F)$}}
			  [\node{\only<-11>{\invisible{$\textit{Edge}(D, F)$}}
			         \only<12>{$\ldots\textit{fail}\ldots$}
			         \only<13-15>{\invisible{$\textit{Edge}(D, F)$}}
			         \only<16->{$\textit{Edge}(D, F)$}}]]]]
\end{frame}
\begin{frame}
	\begin{center}
		\Huge Prolog Example
	\end{center}
\end{frame}


\subsection{Resolution}
\begin{frame}{Resolution}
	\begin{block}{Definition}
		$
		\begin{array}{l}
			p_1 \lor \ldots \lor p_n \\
			q_1 \lor \ldots \lor q_m \\
			\textsc{Unify}(p_i, \lnot q_j) = \theta \\
			\hline
			\textsc{Subst}(\theta, p_1 \lor \ldots p_{i-1} \lor p_{i+1} \ldots \lor p_n \\
			\hspace{4.5em} \lor q_1 \lor \ldots q_{j-1} \lor q_{j+1}  \ldots \lor q_m)
		\end{array}
		$
	\end{block}
	\pause
	\begin{block}{Example}
		$
		\begin{array}{l}
			\lnot \textit{Mammal}(x) \lor \textit{WarmBlooded}(x) \\
			\textit{Mammal}(\textit{Platypus}) \\
			\hline
			\textit{WarmBlooded}(\textit{Platypus})
		\end{array}
		$
	\end{block}
\end{frame}
\begin{frame}{Resolution}
	\begin{block}{Resolution Procedure}
		\begin{enumerate}
			\item Convert knowledge base to CNF
			\item Convert query to CNF
			\item Assume $\lnot$ query
			\item Apply resolution until \textit{false} is concluded
		\end{enumerate}
	\end{block}
	\pause
	\begin{block}{CNF Complications}
		\begin{itemize}
			\item Negations moved through $\forall$ and $\exists$
			\item All quantifiers must have different variable names
			\item Quantifier scopes handled through \alert{skolemization}
		\end{itemize}
	\end{block}
\end{frame}
\begin{frame}{Resolution Example}
	Given:
	\\[.5em]
	$
	\begin{array}{l}
		\lnot\textit{Rich}(x) \lor \lnot\textit{Wants}(x, y) \lor \lnot\textit{Sells}(z, y) \lor \textit{Buys}(x, y) \\
		\lnot\textit{Hot}(x) \lor \lnot\textit{IceCream}(y) \lor \textit{Wants}(x, y) \\
		\lnot\textit{IceCream}(y) \lor \textit{Sells}(\textit{HaagenDazs}, y) \\
		\textit{IceCream}(\textit{Mint}) \\
		\textit{Rich}(\textit{Bill}) \\
		\textit{Hot}(\textit{Bill})
	\end{array}
	$
	\\[1em]
	Prove:
	\\[.5em]
	$
	\begin{array}{l}
		\textit{Buys}(x, y)
	\end{array}
	$
\end{frame}
\begin{frame}{Resolution Example}
	$
	\begin{array}{l}
		\lnot\textit{Buys}(x, y) \\
		\pause
		\lnot\textit{Rich}(x) \lor \lnot\textit{Wants}(x, y) \lor \lnot\textit{Sells}(z, y) \lor \textit{Buys}(x, y) \\
		\hline
		\pause
		\lnot\textit{Rich}(x) \lor \lnot\textit{Wants}(x, y) \lor \lnot\textit{Sells}(z, y)	\\
		\pause
		\textit{Rich}(\textit{Bill}) \\
		\hline
		\pause
		\lnot\textit{Wants}(\textit{Bill}, y) \lor \lnot\textit{Sells}(z, y) \\
		\pause
		\lnot\textit{Hot}(x) \lor \lnot\textit{IceCream}(y) \lor \textit{Wants}(x, y) \\
		\hline
		\pause
		\lnot\textit{Hot}(\textit{Bill}) \lor \lnot\textit{IceCream}(y) \lor \lnot\textit{Sells}(z, y) \\
		\pause
		\lnot\textit{IceCream}(y) \lor \textit{Sells}(\textit{HaagenDazs}, y) \\
		\hline
		\pause
		\lnot\textit{Hot}(\textit{Bill}) \lor \lnot\textit{IceCream}(y) \\
		\pause
		\textit{IceCream}(\textit{Mint}) \\
		\hline
		\pause
		\lnot\textit{Hot}(\textit{Bill}) \\
		\pause
		\textit{Hot}(\textit{Bill}) \\
		\hline
		\pause
		\textit{false}
	\end{array}
	$
\end{frame}
\begin{frame}{Resolution Chaining Properties}
	\begin{block}{Properties}
		\begin{tabular}{@{}ll@{}}
			\keyword{Sound}       & \pause Yes, uses Resolution \\
			\pause\keyword{Complete}    & \pause No, if only binary resolution is used \\
			                        & Yes, with factoring to combine unifiable literals
		\end{tabular}
	\end{block}
	\pause
	\begin{block}{Other Properties}
		\begin{itemize}
			\item Requires extra work to retrieve substitutions
			\item Can produce useless answers for existential goals
		\end{itemize}
	\end{block}
\end{frame}

\part{Key Ideas}
\begin{frame}{Key Ideas}
	\begin{block}{Translating First-Order Logic}
		\begin{itemize}
			\item Identify objects (terms) and relations (predicates)
			\item Generally, use $\limpl$ with $\forall$ and $\land$ with $\exists$
			\item Use inequality to specify unique objects
		\end{itemize}
	\end{block}
	\begin{block}{First-Order Logic Inference}
		\begin{itemize}
			\item Forward chaining on definite clauses is \mbox{sound and complete}
			\item Backward chaining on definite clauses is sound
			\item Resolution is sound and complete
		\end{itemize}
	\end{block}
\end{frame}

\end{document}


